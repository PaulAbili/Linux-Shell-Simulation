C Shell

Contact
Author: Paul Abili
Campus ID:QD36016
Email:pabili1@umbc.edu

Overview
Created a simple c shell. Used the fork() and exec() family of functions the file .421sh is stored within the main directory

Installation and Setup
Libraries used:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <ctype.h>
#include "utils.h" 

Build and Compile
Build & run this program with: make run

NOTE

Only cat /proc/... is supported
not /proc/... 
Additionally no spaces

User-Space Drivers
Driver used :main.c 
This is the only file used in this program, this is the renamed template file

Testing
Throughout implementation of the shell, I tested common linux commands in the my shell and compared the answer to the actual command within the vm
Ex. ls, ls -la, pwd, nano main.c, etc.
Also non commands ex: 1, 2, 3, 4, 5, 6, 7, aa, papas, etc.

Troubleshooting
This was a long process for me so I'll remember everything.

It was super difficult to read the linux manual, so using getline was a lot more difficult than it should have been.

It found it difficult to anticipate how large I should make the ** (when I started it was a *[] but that soon changed)

I didn’t understand how pass by reference worked in c ( I understood that I need to pass by reference to modify a pointer but, I didn’t understand that I needed to dereference a pointer if in functions)

I attempted to use realloc() to shrink the ** to how big it actually needed to be when parsing (it didn’t work so I simply created another ** ( back then it was a *[])

Note on parsing, I initially started using strncpy() and strcpy(), however when it looped the second time, weird stuff started happening to the memory. Eventually after fine tuning my indexes and numbers with my algorithm, I attempted to use memcpy() and it finally worked.

Because of the issues with parsing (the mem issues within the ** was not always apparent)
It took a really long time to understand how the exec family of functions worked.
Additionally, when looking at the example output for the parse_command method: ["ls", "-la", NULL]. I completely misread this and understood it as [“\”ls\””,  “\”-la\””,  “NULL”] which took awhile to figure out ( I really don’t understand why my brain malfunctioned)

This also added to the time it took to figure out the exec() family of functions

Finally implementing the history command was difficult
For some reason, my program would write to the files super oddly
Ex. If the input was:
>> 1
>> 2
>> 3
The file would be written as 
1
1
2
1
2
3
Which didn’t make any sense to me, I spent hours working on it and it was super confusing.
I ended up running the -tail command using exec to circumvent this odd issue, because I was at a loss on how to fix it, and I had spent way to much time working on it

References
External Sources
I spent a lot of time googling answers for questions so it would be impossible to list every source I visited
The main source: geeksforgeeks.org // It was so much easier to understand how these functions worked from this page rather than reading the c documentation, often those documentations pages were super long and didn’t have a lot of examples(if any)
I looked at a lot of pages: strlen, strcpy, strncpy, file handling, exec family of functions,fprint, fgets, fputs and fputc, sprintf, fseek, differences between a, a+, w, w+, r, r+, how to read line by line in , exit abort and assert functions, isspace in c, memcpy, pointer to pointer, fork, c arrays, making your own linux shell, c arrays, wait system call in c, realloc, strcat, null pointer in c, git diff, derefence pointer in c

Videos I watched
https://www.youtube.com/watch?v=HEEzZ7fA9Oo&t=243s
https://www.youtube.com/watch?v=HqADRbshBF4
https://www.youtube.com/watch?v=Lx5r2XQvpVA
https://www.youtube.com/watch?v=2ybLD6_2gKM

I love this man
https://www.youtube.com/watch?v=cex9XrZCU14&t=1s
https://www.youtube.com/watch?v=tcYo6hipaSA
https://www.youtube.com/watch?v=OVFEWSP7n8c
https://www.youtube.com/watch?v=uh2FqejQRk8

